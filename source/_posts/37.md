---
title: Rust  记录一下 debug
date: 1679599730000
tags:
- DEV

url: https://github.com/bxb100/bxb100.github.io/issues/37

---
# Wry
bug 见: https://github.com/tauri-apps/wry/issues/911

1. 把可能出问题的地方打上日志
2. debug 能给出问题的流向, 但是真正出现的地方是隐藏的
3. 看 FFI 的时候不要纠结于外部实现, 90% 不会是调用地方出现问题

---

`objc` 是一个好的学习 bindings 的渠道

---

<a id="issuecomment-1493306499"></a>
问题: [5.2多线程版本](https://course.rs/advance-practice1/multi-threads.html) 的评论 https://github.com/sunface/rust-course/discussions/1157#discussioncomment-5497000

为啥那段程序 `TcpStream` 中会接收到 empty string 导致 `unwrap` panic
复现代码:
client: 
```rust
let mut socket = TcpStream::connect("127.0.0.1:7878").await?;
    socket.shutdown().await?;
    Ok(())
```
server:
```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();
        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&mut stream);

    let request_line = buf_reader.lines().next().unwrap().unwrap();

    let (status_line, filename) = match &request_line[..] {
        "GET / HTTP/1.1" => ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" => {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ => ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };
    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();
    let response = format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
    stream.write_all(response.as_bytes()).unwrap();
    stream.shutdown(Shutdown::Both).unwrap();

```

这里的原因很可能是由于我上面写的那样, client shutdown 了 socket, 然后服务端 `recv` 空的字符串 [^1]

[1]: https://stackoverflow.com/questions/37330993/sock-recv-returns-empty-string-when-connection-is-dead-on-non-blocking-socke